### Stochastic Ray Tracing of 3D Transparent Gaussians

3D Gaussian splatting has recently been widely adopted as a 3D representation for novel-view synthesis, relighting, and text-to-3D generation tasks, offering realistic and detailed results through a collection of explicit 3D Gaussians carrying opacities and view-dependent colors. However, efficient rendering of many transparent primitives remains a significant challenge. Existing approaches either rasterize the 3D Gaussians with approximate sorting per view or rely on high-end RTX GPUs to exhaustively process all ray-Gaussian intersections (bounding Gaussians by meshes). This paper proposes a stochastic ray tracing method to render 3D clouds of transparent primitives. Instead of processing all ray-Gaussian intersections in sequential order, each ray traverses the acceleration structure only once, randomly accepting and shading a single intersection (or N intersections, using a simple extension). This approach minimizes shading time and avoids sorting the Gaussians along the ray while minimizing the register usage and maximizing parallelism even on low-end GPUs. The cost of rays through the Gaussian asset is comparable to that of standard mesh-intersection rays. While our method introduces noise, the shading is unbiased, and the variance is slight, as stochastic acceptance is importance-sampled based on accumulated opacity. The alignment with the Monte Carlo philosophy simplifies implementation and easily integrates our method into a conventional path-tracing framework.

三维高斯投影（3D Gaussian Splatting）近年来被广泛应用于新视角合成、重光照（relighting）以及文本到三维（text-to-3D）生成等任务，凭借一组具有透明度和视角相关颜色的显式三维高斯，实现了真实且细节丰富的结果。然而，在处理大量透明基元时，如何实现高效渲染仍是一项重大挑战。
现有方法通常采用每个视角近似排序的方式对三维高斯进行栅格化，或依赖高端 RTX GPU 来穷举计算所有射线与高斯的交点（通过网格对高斯进行包围）。本文提出了一种用于透明基元三维点云的随机射线追踪（stochastic ray tracing）方法。
该方法不再按顺序处理所有射线与高斯的交点，而是让每条射线只遍历一次加速结构，并随机接受并着色一个交点（或扩展为 N 个交点）。这种做法显著减少了着色时间，避免了对射线方向上高斯的排序，同时最小化了寄存器使用，最大化了并行性，即使在低端 GPU 上也能运行。
在通过高斯资产的射线开销方面，该方法与标准网格交点的射线相当。虽然引入了噪声，但着色是无偏的，并且由于基于累积透明度的重点采样（importance sampling），方差很小。该方法与蒙特卡洛路径追踪的理念一致，便于实现，并可轻松集成到传统的路径追踪框架中。
